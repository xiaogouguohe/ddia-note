# 第2章 数据模型与查询语言

- 多数应用层使用层层叠加的数据模型构建，而对于每层数据模型的关键是：它是如何用低一层数据模型来表示
  - 一个复杂的应用程序可能有很多中间层次，但是基本思想是一样的，即每个层都通过提供一个明确的数据模型，来隐藏更低层次的复杂性
- 本章会研究一系列用于数据存储和查询的通用数据模型
  - 特别地，将比较关系模型，文档模型和少量基于图形的数据模型
  - 还将查看各种查询语言，并比较它们的用例
- 第3章会讨论存储引擎如何工作，也就是这些数据模型是如何实现的

## 2.1 关系模型和文档模型

- 现在最著名的数据模型可能是SQL
  - 数据被组织成关系（表），其中每个关系是元组（行）的无序集合
  - SQL已经成为大多数时候存储和查询某些常规结构的数据的首选工具
  - 关系数据库起源于商业数据处理，这个场景下与一些现在很常见的用例
    - 事务处理（如银行交易，机票预订等）
    - 批处理（工资单）
- 一些其它的数据模型
  - 网络模型
  - 分层模型
  - 对象数据库
  - XML数据库

### 2.1.1 NoSQL的诞生

- NoSQL试图推翻关系模型的统治地位
  - 现在NoSQL被解释为不只是SQL
- 促使NoSQL发展的驱动因素
  - 需要比关系型数据库更好的可伸缩性
  - 免费开源的软件更受偏爱
  - 关系模型不能很好地支持一些特殊的查询操作
  - 关系模型有一些限制性
- 在未来，关系型数据库很可能会继续与各种非关系数据库一起使用（混合持久化）

### 2.1.2 对象关系不匹配

- 目前大多数应用程序都使用面向对象的编程语言来开发，这导致了对SQL的批评：需要一个转换层，在代码中的对象和数据库模型之间？？？
  - 这种模型之间的不连贯被称为阻抗不匹配
  - 对象关系映射框架可以减少转换层所需的代码量，但是不能完全隐藏这两个模型之间的差异

- 一个例子，用关系模型表示简历，见图2-1
  - 整个简历可以通过唯一的标识符user_id来标识
  - first_name和last_name字段，每个用户也只有一个，所以可以在User表上将其建模为列
  - 大多数人不止做过一份工作，教育经历可能不止一段，联系方式可能不止一个，这些一对多的关系可以用多种方式表示
    - 传统SQL模型，把置位，教育经历和联系方式分别放到单独的表中，如图2-1的positions表，education表和contact_info表
    - 后续的SQL标准增加了对结构化数据类型和XML数据的支持，允许将多值数据存储在单行内
    - 将职业，教育经历和联系信息编码为JSON或XML文档，将其存储在数据库的一个文本列中，由应用程序解析其结构和内容
      - 例2-1展示了JSON文档如何表示这个简历

- JSON模型的评价
  - 有些开发人员认为JSON模型减少了应用程序代码和存储层之间的阻抗不匹配
  - JSON作为数据编码格式也存在问题（第4章）
    - 缺乏一个模式被认为是一种优势（见“文档模型中的模式灵活性”）
  - JSON比夺标模式具有更好的局部性
    - 如果在关系型示例中获取简介，就要执行多个表查询或多路连接
    - 在JSON表示中，所有相关信息都在同一个地方，一个查询就足够了
  - 一对多关系隐含了树状结构，JSON使得这种树状结构很明确，如图2-2

### 2.1.3 多对一和多对多的关系

- 在例2-1中，region_id和industry_id是以ID，而不是字符串形式给出的，在不同场景下，应该怎么存储这些字段
  - 如果用户界面用一个自由文本字段来输入区域和行业，那么将他们存储为纯文本字符串是合理的
  - 另一方式是给出区域和行业的列表，让用户进行选择，优势如下
    - 各个简介之间的样式和拼写统一
    - 避免歧义，如果有同名的城市，可以进行一些标注
    - 易于更新，名称只存储在一个地方
    - ###
  - 存储ID还是文本字符串，是一个副本问题
    - 若存储ID，就通过一张表存储ID和实际意义，而所有用到它们的地方都使用ID
    - 若存储文本，则将文本复制到每条记录
  - 使用ID的好处是，ID可以永远不改变，即便它标识的信息发生变化，也只需要改ID-实际意义这张表；而如果存储文本，那么文本发生变化时，所有引用到它的地方都要更新
    - 如果重复存储了可以存储在一个地方的值，那这个模式就不是规范化的
    - 去除这类重复是数据库规范化的关键思想
    - 在本书的第三部分，会回到规范化的话题
  - 不幸的是，对这些数据进行规范化，需要多对一的关系
    - 许多人生活在特定的地区，许多人在特定的行业工作
    - 注意多对一和一对多区分，上面一条是多对一，一对多例如一个人有不止一份工作经历
    - 多对一关系与文档模型不太吻合，直接像之前那样，一个求职者一个json串不可以吗？？？
      - 在关系数据库中，通过ID来引用其他表中的行是正常的，因为连接很容易
      - 在文档数据库中，一对多树结构本身没必要用连接，因此对连接的支持很弱
      - 可以直接把地区这些信息写到json串，但是正如后面所说，一个地区可能不仅仅是一个字符串，而是一个很大的实体
  - 如果数据库本身不支持连接，就需要在应用程序代码中，通过对数据库进行多个查询来模拟连接？？？
- 通过对简历进行一些修改，表明了即使应用程序的最初版本适合无连接的文档模型，但是随着功能添加到应用程序中，数据会更加互联
  - 组织和学校作为实体
    - 在之前的描述中，organization和schllo_name只是字符串
    - 实际上，它们也可能是对实体的引用，每个组织，学校都可以有自己的网页
    - 每个简历可以链接到它提到的组织和学校，如图2-3
  - 推荐
    - 添加一个新功能，一个用户可以给另一个用户写一个推荐
    - 用户的简历上会显示推荐，推荐应该拥有坐着个人简历的引用
- 图2-4展示了这些新功能如何使用多对多关系
  - 每个虚线框内的数据可以分组成一个文档
  - 对单位，学校和其他用户的引用，需要表示成引用，且在查询的时候需要连接
    - 单位，学校和其它用户，没法直接作为value放到文档里，需要单独一个文档

### 2.1.4 文档数据库是否在重蹈覆辙

- 在多对多的关系和连接已经常规用在关系数据库时，文档数据库和NoSQL重启了辩论：如何最好地在数据库中表示多对多关系

- 层次模型
  - IMS是IBM的信息管理系统，它使用了层次模型
  - 层次模型是个很老的东西，和文档数据库使用的JSON模型有很大相似
    - 所有数据都被表示为嵌套在记录中的记录树，类似于图2-2
    - 所以通过讨论它的局限性，以及提出来的解决办法，来探讨“文档数据库是否在重蹈覆辙”
  - 同文档数据库一样，IMS很难应对多对多的关系，且不支持连接
    - 开发人员必须决定是否复制数据，或者手动解决从一个记录到另一个记录的引用
  - 人们提出了一些解决方案，其中最突出的两个是关系模型（后来成了SQL）和网络模型（最初受关注，现在冷门）
    - 这两个模型与当前的问题相关，需要回顾那场辩论

#### 2.1.4.1 网络模型

- 网络模型是对层次模型的推广
  - 层次模型的树结构中，每条记录只有一个父节点；网络模式中，每条记录可能有多个父节点，例如地区名可能是一条记录，每个居住在该地区的用户都可以成为这条记录的父节点
- 记录之间的链接不是外键，而是类似于编程语言中的指针（磁盘上的）访问记录的唯一方法是跟随从根记录起沿着这些链路形成的路径，这条路径被称为访问路径
- 最简单的情况下，访问路径类似于链表，但在多对多关系统，数条不同的路径可以到达相同的记录，程序员必须跟踪这些不同的访问路径
  - 访问非常不方便，像是在n维空间进行导航
- 手动选择访问路径能够有效利用硬件（在以前硬件资源是很珍贵的），但这使得查询非常不灵活，如果没有所需数据的访问路径，就会陷入困境
  - 可以改变访问路径，但是需要手动改查询代码
- 为什么说网络模型需要程序员生成访问路径，可以举一个例子吗？？？

#### 2.1.4.2 关系模型

- 一个关系（表）只是一个元组（行）的集合
  - 如果想读取数据，没有嵌套结构和复杂的访问路径，可以直接选中任何行
- 关系数据库中，查询优化器决定了查询的哪些部分以哪些顺序执行，以及使用哪些索引
  - 这些选择其实就是访问路径，但是和网络模型不一行的就是，这些是查询优化器生成的，而不是程序员生成的
  - 为什么说这些选择也是访问路径？？？
- 如果想按照新的方式查询数据，可以声明新的索引，查询会自动使用最适合的那些索引
  - 参考2.2“数据查询语言”
- 关系数据库的查询优化器

  - 如果能构建查询优化器，那么只需构建一次，随后所有使用数据库的应用程序都可以收益
  - 否则，可以为特定查询手动编写范文路径

#### 2.1.4.3 与文档数据库相比

- 从某种意义上来说，文档数据库被还原为层次模型：在父记录中存储嵌套记录（图2-1的一对多关系，如education，positions，一个人有多份教育经历和工作经历，它们都被记录在同一个父记录中），而不是在单独的表中；而关系数据库会有人-教育经历表，人-工作经历表，且每一行都是一份教育或工作经历、

- 但是在表示多对一和多对多关系时，关系数据库和文档数据库没有本质不同
  - 相关项目都被一个唯一的标识符引用
  - 这个标识符在关系模型中被称为外键，在文档模型中被称为文档引用
    - 例如人-推荐者，推荐者是外键或文档引用，需要到别的表或文档
  - 该标识符在读取时通过连接或后续查询来解析

### 2.1.5 关系型数据库与文档数据库在今日的对比

- 两者进行比较时，可以考虑这些方面的差异
  - 容错性（第5章）
  - 处理并发性（第7章）
  - 数据模型中的差异，这是本章关注的内容
- 两者在数据模型上的特性
  - 支持文档数据模型的论据有架构灵活性，因为局部性而有更好的性能，以及某些时候更接近应用程序使用的数据结构
  - 关系模型能给连接提供更好的支持，因而更支持多对一和多对多关系
- 下面会对两者的数据模型的特性做进一步讨论

#### 2.1.5.1 哪种数据模型更有助于简化应用代码

- 如果应用程序中的数据有类似文档的结构，例如一对多关系树
  - 使用文档模型比较好，可以一次性加载整个树
  - 如果想把类似的文档结构分解成多个表，，如图2-1中的positions，education和contact_info这几个表，可能会使应用程序更复杂
- 文档模型的局限性
  - 文档模型和层次模型的思路在很多方面是相似的，因此层次模型的问题，文档模型都没法避免，而网络模型又是层次模型的扩展，只是引进了多对多，因此文档模型的局限性可以参考之前介绍层次模型和网络模型的时候，这里再简单介绍一下
  - 引用路径可能比较繁琐，尤其是访问的对象被嵌套得比较深的时候
  - 对连接的支持比较糟糕，在多对多连接的时候会导致应用程序的复杂性

- 很难下结论说哪种数据模型更有助于简化应用代码，因为它取决于数据项之间的关系种类
  - 对于高度关联的数据而言，文档模型非常糟糕，关系模型可以接受，而图形模型（见2.3）是最自然的

#### 2.1.5.2 文档模型中的架构灵活性

- 数据的模式

  - 没有模式意味着可以将任意的建和值添加到文档中，并且读取时无法保证文档可能包含的字段
  - 大多数文档数据库，和关系数据库中的JSON支持都不会限制文档中的数据模式

- 无模式，读时模式和写时模式

  - 文档数据库被称为读时模式，数据结构是隐含的，只有在数据被读取时才解释
  - 传统的关系数据库中，模式明确（每个字段的类型都是确定的，INT，CHAR等等），且写入的时候就会保证数据符合模式

- 在应用程序想改变数据格式（模式）的情况下，这些方法的区别尤为明显

  - 例如，假如原先每个用户的全名已经被存储在一个字段中，现在想分别存储名字和姓氏

  - 在文档数据库中，只需要开始写入具有新字段的新文档，并且在应用程序中使用代码处理读取旧文档的情况，如

    ```go
    if (user && user.name && !user.first_name) {
    	// Documents written before Dec 8, 2013 don't have first_name
    	user.first_name = user.name.split(" ")[0];
    }
    ```

    什么叫做“写入具有新字段的文档”？？？

  - 在关系数据库中，通常会执行迁移操作，什么是迁移？？？

    ```sql
    ALTER TABLE users ADD COLUMN first_name text;
    UPDATE users SET first_name = split_part(name, ' ', 1); 		-- PostgreSQL
    UPDATE users SET first_name = substring_index(name, ' ', 1); 	-- MySQL
    ```

- 模式变更的速度很慢，而且要求停运

  - 不是所有时候，这种变更都会很慢，例如大多数关系型数据库都可在几毫秒内执行 `ALTER TABLE` 语句
  - MySQL执行 `ALTER TABLE` 时会复制整个表，这意味着更改大型表可能需要几分钟甚至几小时

  - 任何数据库在运行 ·UPDATE` 时都可能很慢，因为每一行都要重写
    - 在应用程序角度，可以先把列设置为 `NULL` ，并在读取时再填充，和文档数据库做法类似

- 当集合中的项目并不都具有相同的结构时，读时模式更具优势

  - 存在许多不同类型的对象
  - 数据的结构由外部系统决定，而外部系统随时可能变化
  - 无模式文档可能更加自然，但是如果所有的记录都具有相同的结构，那么模式是记录并且强制规范这种结构的有效机制
    - 这里的无模式是不是读时模式？？？
  - 模式和模式演化的更多讨论见第4章

#### 2.5.1.3 查询的数据局部性



